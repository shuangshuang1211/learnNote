- GC几种方法

  - 引用计数

    用计数器保存当前对象的引用次数，每次引用改变就修改次数如果为0就立即进行清除

    优点：及时回收、减少停顿

    不能解决循环引用的问题

    每次需要查找当前变量引用值会影响性能

  - 标记清除

    从根即全局变量对象开始向下查找每个节点，如果节点能访问到则表示改节点的引用对象是可达对象，如此递归查找直到末尾，(可达即可访问，当前对象是否还存在于VOG及相关作用域链？)，被遍历到的节点则进行标记，剩余没有被标记的节点就是需要清理的，再统一清理没有标记的变量

    容易造成内存碎片化，解决了引用计数循环引用的问题

  - 标记整理

    在标记清除基础上，遍历对象进行标记，然后对标记的变量进行一次整理，然后再清理，这样就可以得连续的空闲内存空间

- V8引擎GC的机制(分代回收)(标记清理、空间赋值(Scavange)、标记整理Mark-Sweep、增量标记Mark-Compact)

  - V8, chrome对于64位默认分配1.5G以下(一般1.4G，在这个范围内对浏览器刚好够用且这个大小内的垃圾非增量回收时间刚好不会超过1s，不会造成全停顿的现象)内存给浏览器，32则是1G以下（一般800M左右）

  - 分代回收，一般给默认内存空间分为两部分，一部分是新生代(存在周期短占用内存较小的活动对象)，一部分是老生代(长期存在且占用内存较大的对象)

  - 新生代标记整理和空间复制(Scavange)，新生代区域分为from-space和空闲to-space两部分，把From-sapce的存活的活动对象标记；并复制到to-Spcae内，并将这些内存进行有序的排列，然后清除未标记的内容并对内存进行释放，然后交换to-space与form-space，这实际上是用空间换取时间；

  - 在新生代还进行了更细的区分，分为nursery 子代和 intermediate子代，对象第一次进入内存空间会被分配在 nursery子代中，经过一次垃圾回收后还存在，则会移动到intermediate中，再经过一次垃圾回收还存在，则会晋升到老生代， 有时标记的数据比较大的时候会直接晋升为老生代

  - 老生代因为存放数据比较大且存活时间比较长，不适用Scavange算法，主要是用Mark-Sweep和Mark-Compact，标记清理主要经过两个阶段：

    ​	标记阶段，进行第一次扫描，标记活动对象；

    ​	清理阶段，进行第二次扫描，清理未标记对象；

    标记清理后有时候会留下许多零散的不连续的内存片段，如果此时进来一个较大的数据，则会为此增加大量时间寻找合适的内存空间，为了增加性能在此基础上就增加一次内存整理，会把剩下的活动对象整理到内存的一侧。

  - 因为js代码执行用到引擎，垃圾回收也需要引擎来做，如果同时发生，则会出现js执行停顿的现象，对于新生代的垃圾回收，因为存活的活动对象较少，且用Scavange，停顿较短，但对于老生代数据而言，如果活动对象较多的时候则可能造成较长时间的停顿；

  - 增量标记、惰性清理、并发、并行

  - 增量标记，这是对应于标记阶段的优化，对于垃圾比较多时，会标记一段js执行一段再标记...，增量标记因为是标记一段执行一段，所以需要写一些屏障保护技术来记录每个变量引用关系的变化，以确保不会出错

  - 惰性清理，则是对应于清除阶段，对于增量标记后，垃圾回收器发现就算不清理这些垃圾代码也能正常执行则会延迟清理

  - 并发GC允许垃圾回收的时候不需要将主线程挂起，只是在个别需要特殊操作会做短暂的停顿

  - 并行GC，在GC运行时，有其他的并行GC线程做一些辅助工作